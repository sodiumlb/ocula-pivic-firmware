/*
 * Copyright (c) 2025 Sodiumlightbaby
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

; Oric ULA PHI clock driver output
; Assuming 138MHz sys_clk - 46 cycles per phase for 1MHz 3-phase clock
; Using 2x clock divider for SM = sys_clk/2 -> 23 cycles per phase
; Each phase asserts a PIO IRQ flag for system synchronization
.program phi
.side_set 1
.clock_div 2.0

.wrap_target
 irq 0      side 0
 irq prev 0 side 0 [14]     ;sync RGBS PIO program in pio#-1
 nop        side 0 [ 6]
 irq 1      side 0 [15]
 nop        side 0 [ 6]
 irq 2      side 1 [15]
 nop        side 1 [ 6]
.wrap

; Oric RGB+Sync output driver
; Assuming 138MHz sys_clk - 23 cycles periodes for 6MHz pixel clock
; Outputs 6 4-bits value in series. The series can run up to 256 times
; repeat = 0 => one pass of values output, 1 => two passes of values output
; |repeat|v0|v1|v2|v3|v4|v5|
;     8    4  4  4  4  4  4 
.program rgbs
.out 32 left

.wrap_target
    pull ;noblock
    out y 8             ;get repeat value
    mov isr osr         ;keep copy of values in isr
repeat:
    set x 4             ;6 values -1 -1 count down
    mov osr isr         ;restore values in osr
    wait 1 irq 0        ;sync start of series with phi
series:
    out pins 4     [21]
    jmp x-- series
    out pins 4          ;last in series w/o delay
    jmp y-- repeat
.wrap

; RAM emulation - read & write from/to xram
; Address of the memory to read from is set in x by setup
; DMA setup required to take the address, fetch data and return
; Autopull and autpush used
.program xread
.in 16 left auto 16
.out 8 right auto 8
.wrap_target
    wait 0 gpio 29 [30] ; sample address ca 300ns after phi0 falling edge 
    mov isr x      [10] ; Base address to fetch from in the system
    in pins 16          ; Pull in rest of address from 6502
    out pins 8          ; Blocking till data returns. pindirs set elsewhere
    wait 1 gpio 29      ; Make sure only one iteration per phi clock
.wrap

; Address of the memory to write to is set in x by setup
; DMA setup required to take the address then data and write to memory
.program xwrite
.in 32 left
.out 32 right
.wrap_target
start:
    wait 1 gpio 29      ; Wait for phi0 rising edge 
    jmp pin start       ; If read, go back to start
    mov osr pins        ; Capture D[7:0],PHI,A[15:0],RnW,nMAP
    out null 9          ; Spool out D[7:0], PHI
    mov isr x           ; System top address bits
    in osr 16           ; shift in bottom address
    wait 0 gpio 29      ; Wait for phi0 falling edge before capturing data
    push noblock        ; Send address to FIFO
    mov isr pins        ; Move data to isr
    push noblock        ; Send data to FIFO
.wrap

.program xdir
.set 1
.in 1 left
.out 8 right
.wrap_target
start:
    wait 1 irq 0        ; Wait for, then clear IRQ. Signaled by decode. Only run if not ROM or IO
    jmp pin dir_out     ; If PHI pin is high, jump to dir_out 
    jmp start           ; else return to IRQ loop
dir_out:
    mov y pins          ; Get RnW
    jmp !y start        ; If write, abort output
    set pins 0          ; Set DIR on external bus transciver to output
    mov pindirs ~null   ; Set data pins to output
    wait 0 gpio 29 [30] ; Wait for phi0 falling edge + ca 40 + 60ns for data hold
    mov pindirs null    ; Disable data pins output
    set pins 1          ; Set DIR on external bus transciver to input
.wrap

; Decode logic for driving DIR and indirectly nROMSEL and nIO
; PIO needs to run in upper GPIO bank while nROMSEL and nIO is in lower
; Requires nMAP to be polarity inverted in GPIO setup 
; This program freeruns to get close to the original decode logic behaviour
; x set to 0x3 in setup for comparing to A[15:8] and A[15:14]
.program decode
.in 8 left
.out 32 right
.wrap_target
start:
    mov y pins          ; Get A15-A8
    jmp x!=y not_io     ; Skip if not page 3
is_io:
    irq prev set 1      ; Assert nIO
    irq prev clear 2    ; Clear nROMSEL
    jmp start
not_io:
    jmp pin not_rom     ; if MAP is asserted
    mov osr pins        ; Get A15-A8
    out null 6          ; Spool out A13-A8
    out y 2             ; Get A15-A14
    jmp x!=y not_rom    ; Skip if not [A15:A14]==0b11
is_rom:
    irq prev clear 1    ; Clear nIO
    irq prev set 2      ; Assert nROMSEL
    jmp start
not_rom:
    irq prev clear 1    ; Clear nIO
    irq prev clear 2    ; Clear nROMSEL
    irq next set 0      ; Signal xdir on pio#+1 
.wrap

; nIO pin program
; Controlled by ula_decode running in PIO+1
; Active low with pin drive on side set
.program nio
.side_set 1
.wrap_target
    wait 1 irq 1  side 1  ; Clear pin and wait for IRQ raised
    irq wait 1  side 0    ; Assert pin and IRQ (again), and wait for IRQ cleared
.wrap

; nROMSEL pin program
; Controlled by ula_decode running in PIO+1
; Active low with pin drive on side set
.program nromsel
.side_set 1
.wrap_target
    wait 1 irq 2  side 1  ; Clear pin and wait for IRQ raised
    irq wait 2  side 0    ; Assert pin and IRQ (again), and wait for IRQ cleared
.wrap

.program trace
.in 27 left auto 27
.wrap_target
    wait 1 irq 2 [12]
    in pins 27
.wrap