/*
 * Copyright (c) 2025 Sodiumlightbaby
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

; Oric ULA PHI clock driver output
; Assuming 138MHz sys_clk - 46 cycles per phase for 1MHz 3-phase clock
; Using 2x clock divider for SM = sys_clk/2 -> 23 cycles per phase
; Double clocking sys_clk -> sys_clk/4
; Each phase asserts a PIO IRQ flag for system synchronization
.program phi
.side_set 1
.clock_div 4.0

.wrap_target
 irq 0      side 0
 irq prev 0 side 0 [14]     ;sync RGBS PIO program in pio#-1
 nop        side 0 [ 6]
 irq 1      side 0 [15]     ;second ULA phase irq - trigger first decode program phase (IO)
 irq next 1 side 0 [ 6]     ;trigger xula ending data output
 irq 2      side 1 [15]     ;CPU phase irq - trigger second decode program phase (MAP)
 nop        side 1 [ 6]
.wrap

; Oric RGB+Sync output driver
; Assuming 138MHz sys_clk - 23 cycles periodes for 6MHz pixel clock
; Outputs 6 4-bits value in series. The series can run up to 256 times
; repeat = 0 => one pass of values output, 1 => two passes of values output
; |repeat|v0|v1|v2|v3|v4|v5|
;     8    4  4  4  4  4  4 
.program rgbs
.clock_div 2.0
.out 32 left

.wrap_target
    pull ;noblock
    out y 8             ;get repeat value
    mov isr osr         ;keep copy of values in isr
repeat:
    set x 4             ;6 values -1 -1 count down
    mov osr isr         ;restore values in osr
    wait 1 irq 0        ;sync start of series with phi
series:
    out pins 4     [21]
    jmp x-- series
    out pins 4          ;last in series w/o delay
    jmp y-- repeat
.wrap

; RAM emulation - read & write from/to xram
; Address of the memory to read from is set in x by setup
; DMA setup required to take the address, fetch data and return
; Autopull and autpush used
.program xread
.clock_div 2.0
.in 16 left auto 16
.out 8 right auto 8
.wrap_target
    wait 0 gpio 29 [31] ; sample address ca 300ns after phi0 falling edge
    mov isr x      [10] ; Base address to fetch from in the system
    in pins 16          ; Pull in rest of address from 6502
    wait 1 gpio 29      ; Wait rising edge of phi0
    out pins 8          ; Blocking till data returns. pindirs set elsewhere
    wait 1 gpio 29      ; Make sure only one iteration per phi clock
.wrap

; Address of the memory to write to is set in x by setup
; DMA setup required to take the address then data and write to memory
.program xwrite
.in 32 left
.out 32 right
.wrap_target
start:
    wait 1 gpio 29      ; Wait for phi0 rising edge 
    jmp pin start       ; If read, go back to start
    mov osr pins        ; Capture D[7:0],PHI,A[15:0],RnW,nMAP
    out null 9          ; Spool out D[7:0], PHI
    mov isr x           ; System top address bits
    in osr 16           ; shift in bottom address
    wait 0 gpio 29      ; Wait for phi0 falling edge before capturing data
    push noblock        ; Send address to FIFO
    mov isr pins        ; Move data to isr
    push noblock        ; Send data to FIFO
.wrap

.program xdir
.set 1
.in 1 left
.out 8 right
.wrap_target
start:
    wait 1 irq 0        ; Wait for, then clear IRQ. Signaled by decode. Only run if not ROM or IO
    wait 1 gpio 29 [30] ; Wait for phi0 rising edge + setup time
dir_out:
    mov y pins          ; Get RnW
    jmp !y start        ; If write, abort output
    set pins 0          ; Set DIR on external bus transciver to output
    mov pindirs ~null   ; Set data pins to output
    ;data output disable now in xula program
.wrap

; Output screen data during ULA owned phase of clock
; Partly mimics real ULA access to screen memory 
; so that e.g. LOCI can detect screen mode
; TODO consider replacing with API function to save PIO resources

.program xula
.set 1
.out 8 right
.wrap_target
    wait 0 gpio 29 [30] ; Wait for falling edge of phi0 (beginning of ULA phase of bus cycle)
    pull noblock        ; Get data - but don't block if not ready
    out pins 8          ; Put data in output buffer
    set pins 0          ; Set DIR on external bus transciever to output
    mov pindirs ~null   ; Set data pins to output
    wait 1 irq 1        ; Wait for singnal from phi program (and clear it)
    mov pindirs null    ; Set data pins to input
    set pins 1          ; Set DIR on external bus transciever to input
    wait 1 gpio 29 [30] ; Wait for rising edge on phi0
.wrap

; Decode logic for driving DIR and indirectly nROMSEL and nIO
; PIO needs to run in upper GPIO bank while nROMSEL and nIO is in lower
; Requires nMAP to be polarity inverted in GPIO setup 
; This program is triggered by the phi program irq 2
; x set to 0x3 in setup for comparing to A[15:8] and A[15:14]
.program decode
;;.clock_div 2.0
.in 8 left
.out 32 right
.wrap_target
start:
    irq clear 2         ; Make sure second phase IRQ trigger is cleared
    wait 1 irq 1        ; Wait for phi program trigger
    mov y pins          ; Get A15-A8
    jmp x!=y not_io     ; Skip if not page 3
is_io:
    irq prev clear 2    ; Clear nROMSEL
    irq prev set 1      ; Assert nIO
    jmp start
not_io:
    irq prev clear 1    ; Clear nIO
    mov osr pins        ; Get A15-A8
    out null 6          ; Spool out A13-A8
    out y 2             ; Get A15-A14
    jmp x!=y not_rom    ; Skip if not [A15:A14]==0b11
    wait 1 irq 2   [10] ; Wait for phi program trigger + MAP signal margin
    jmp pin not_rom     ; Skip if MAP is asserted
is_rom:
    irq prev set 2      ; Assert nROMSEL
    jmp start
not_rom:
    irq prev clear 2    ; Clear nROMSEL
    irq next set 0      ; Signal xdir on pio#+1 
.wrap

; nIO pin program
; Controlled by ula_decode running in PIO+1
; Active low with pin drive on side set
.program nio
;;.clock_div 2.0
.side_set 1
.wrap_target
    wait 1 irq 1  side 1  ; Clear pin and wait for IRQ raised
    irq wait 1  side 0    ; Assert pin and IRQ (again), and wait for IRQ cleared
.wrap

; nROMSEL pin program
; Controlled by ula_decode running in PIO+1
; Active low with pin drive on side set
.program nromsel
;;.clock_div 2.0
.side_set 1
.wrap_target
    wait 1 irq 2  side 1  ; Clear pin and wait for IRQ raised
    irq wait 2  side 0    ; Assert pin and IRQ (again), and wait for IRQ cleared
.wrap

.program trace
.clock_div 2.0
.in 27 left auto 27
.wrap_target
    wait 1 irq 2 [12]
    in pins 27
.wrap