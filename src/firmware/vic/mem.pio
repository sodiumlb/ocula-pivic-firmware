/*
 * Copyright (c) 2025 Sodiumlightbaby
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */


; RAM emulation - read & write from/to xram
; Address of the memory to read from is set in x by setup
; DMA setup required to take the address, fetch data and return
; Autopull and autpush used
.program xread
.clock_div 2.0
.in 14 left auto 14
.out 8 right auto 8
.wrap_target
    mov isr x           ; Base address to fetch from in the system
    wait 0 irq 0   [24] ; sample address after phi1 falling edge 
    in pins 14          ; Pull in rest of address from 6502
    out pins 8          ; Blocking till data returns. pindirs set elsewhere
.wrap

; Address of the memory to write to is set in x by setup
; DMA setup required to take the address then data and write to memory
; A14 = '0' for BLK4 writes - data in same CPU period
; A14 = '1' for non BLK4 writes - data in following VIC period
.program xwrite
.clock_div 2.0
.in 32 left
.out 32 right
.wrap_target
start:
    mov isr x           ; System top address bits
    wait 1 irq 3        ; Wait for write detect in xdir program
    mov osr pins        ; Capture RnW, A[13:0], D[11:0]
    out null 24         ; Spool out A[11:0], D[11:0]
    out y 2             ; Inspect A[13:12]
    jmp !y start        ; If zero then CHR ROM, abort capturing the write
    mov osr pins        ; Capture RnW, A[13:0], D[11:0]
    out y 12            ; Keep D[11:0] in y (in case BLK4)
    in osr 14           ; shift in bottom address
    push noblock        ; Send address to FIFO
    jmp pin not_blk4    ; If A13=='1', this write is not for BLK4
    mov isr y           ; BLK4 write, use data from y
    jmp push_data
not_blk4:
    wait 1 pin 26  [25] ; Wait for RnW rising edge before capturing not BLK4 data
    mov isr pins        ; Assume not BLK4, capture new data in isr
push_data:
    push noblock        ; Send data to FIFO
.wrap

; Direction control of data bus
; Enable output when address in x (set by setup)
; matches incoming address and read is enabled

.program xdir
.clock_div 2.0
.in 7 left
.out 8 right
.wrap_target
start:
    wait 0 irq 1   [29] ; Wait for phi1 rising edge + ca 200ns for data hold
    mov pindirs null    ; Disable data pins output
    wait 0 irq 0   [29] ; Wait for phi1 falling edge + ca 200ns for address hold
    jmp pin isread      ; Sample RnW pin skip next if read
    irq set 3           ; Signal xwrite program
isread:
    mov y pins          ; Get A[13:8],RnW
    jmp x!=y start      ; If not reading of registers, goto start 
    irq set 2           ; Signal trace
    mov pindirs ~null   ; Set data pins to output
.wrap

; Bus tracing function
; TODO Not updated for VIC integration yet
.program trace
.in 27 left auto 27
.wrap_target
    wait 1 irq 2 [0]
    in pins 27
.wrap

; Capturing data bus during VIC phase
; Used to emulate behaviour of unconnected memory access

.program xuncon
.clock_div 2.0
.in 8 left
.fifo txput
.wrap_target
    wait 0 irq 1      [29] ; Wait for phi1 rising edge (VIC phase start)
    mov isr pins           ; Get data
    mov rxfifo[0] isr      ; Move data to RX FIFO register 0
.wrap

; Program to mask out bit 7-4 in a word when bit 31-8 matches register xdir
; Used by xread and xwrite DMA chain to make VIC register space wrapping work
; Same program used for both xread and xwrite as the data sent by xwrite will never
; match and pass unchanged through
; Matching address set in x (A31-A15=xram, A14-A8=0x10)
; If so, strip A7-A4 
.program mask_address
.in 1 left auto 32
.out 1 left auto 32
.wrap_target
    out y 24                  ; get A31-A8 in y (autopull)
    in y 24                   ; copy A31-A8 to isr
PUBLIC enable:
    jmp x!=y no_mask          ; jump if not VIC register access
mask:
    out null 4                ; dump out 4 bits A7-A4
    out y 4                   ; shift out 4 bits A3-A0 to y
    jmp finish                ; jump to the output stage
PUBLIC no_mask:
    out y 8                   ; get A7-A0 in y
finish:
    in y 8                    ; autopush
.wrap